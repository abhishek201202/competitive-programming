{
	"": {
		"prefix": "Dijkstra",
		"body": [
		  "const int N = 1e5;",
		  "vector<int> adj[N] , weight[N];",
		  "int dis[N];",
		  "int n , m;",
		  "",
		  "class cmp{",
		  "public:",
		  "	bool operator()(pii a , pii b){",
		  "		return a.ss > b.ss;",
		  "	}",
		  "};",
		  "",
		  "// single source shortest path ",
		  "// not work for negative weighted graph",
		  "void dijkstra(int s){",
		  "	for(int i = 0 ; i < n ; i++) dis[i] = 1e8;",
		  "	dis[s] = 0;",
		  "",
		  "	priority_queue<pii , vector<pii> , cmp> pq;",
		  "	pq.push({s , 0});",
		  "	",
		  "	while(pq.size() != 0){",
		  "		pii curr = pq.top();",
		  "		pq.pop();",
		  "		int u = curr.ff;",
		  "		int w = curr.ss;",
		  "		if(w > dis[u]) continue; // very important => TLE if we not put this cond",
		  "		for(int i = 0 ; i < adj[u].size() ; i++){",
		  "			int v = adj[u][i];",
		  "			if(dis[v] > dis[u] + weight[u][i] && weight[u][i] != 0){",
		  "				dis[v] = dis[u] + weight[u][i];",
		  "				pq.push({v , dis[v]});",
		  "			}",
		  "		}",
		  "	}",
		  "}"
		],
		"description": ""
	  }
}